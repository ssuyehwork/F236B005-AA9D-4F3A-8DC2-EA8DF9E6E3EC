# -*- coding: utf-8 -*-# services/preview_service.pyfrom PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel, QTextEdit, QWidget, QDesktopWidget, QShortcutfrom PyQt5.QtCore import Qt, QPointfrom PyQt5.QtGui import QPixmap, QKeySequence, QFont, QColorfrom core.config import COLORS, STYLESclass PreviewDialog(QDialog):    """    独立的预览窗口 UI 类    """    def __init__(self, item_type, data, parent=None):        super().__init__(parent)        # Popup 模式：无边框，且点击窗口外部会自动关闭（配合 toggle 逻辑使用）        # 如果希望点击外部不关闭，可以去掉 Qt.Popup，仅保留 FramelessWindowHint        self.setWindowFlags(Qt.FramelessWindowHint | Qt.Popup)        self.setAttribute(Qt.WA_TranslucentBackground)        self.setAttribute(Qt.WA_DeleteOnClose) # 关闭时自动销毁对象                self._init_ui(item_type, data)    def _init_ui(self, item_type, data):        # 主布局        main_layout = QVBoxLayout(self)        main_layout.setContentsMargins(0, 0, 0, 0)                # 内容容器（带边框和背景，实现圆角和阴影效果的基础）        container = QWidget()        container.setStyleSheet(f"""            QWidget {{                background-color: {COLORS['bg_dark']};                border: 2px solid {COLORS['primary']};                border-radius: 12px;            }}        """)        container_layout = QVBoxLayout(container)        container_layout.setContentsMargins(10, 10, 10, 10)        main_layout.addWidget(container)        # 根据类型渲染内容        if item_type == 'text':            self._setup_text_preview(container_layout, data)        elif item_type == 'image':            self._setup_image_preview(container_layout, data)                # 底部提示        hint_label = QLabel("按 [Space] 或 [Esc] 关闭")        hint_label.setAlignment(Qt.AlignCenter)        hint_label.setStyleSheet("color: #666; font-size: 10px; margin-top: 5px; border: none; background: transparent;")        container_layout.addWidget(hint_label)    def _setup_text_preview(self, layout, text_data):        self.resize(600, 450)                text_edit = QTextEdit()        text_edit.setReadOnly(True)        text_edit.setText(text_data)        text_edit.setFont(QFont("Microsoft YaHei", 12))        text_edit.setStyleSheet(f"""            QTextEdit {{                background-color: transparent;                border: none;                padding: 10px;                color: #ddd;            }}            /* 引用全局配置中的滚动条样式（如果存在） */            QScrollBar:vertical {{                border: none;                background: #222222;                width: 10px;                margin: 0px;            }}            QScrollBar::handle:vertical {{                background: #555555;                min-height: 20px;                border-radius: 5px;            }}        """)        layout.addWidget(text_edit)        self._center_on_screen()    def _setup_image_preview(self, layout, image_data):        pixmap = QPixmap()        pixmap.loadFromData(image_data)        if pixmap.isNull():            label = QLabel("❌ 图片加载失败")            label.setStyleSheet("color: #e74c3c; font-size: 16px; border: none; background: transparent;")            label.setAlignment(Qt.AlignCenter)            layout.addWidget(label)            self.resize(300, 200)        else:            label = QLabel()            label.setAlignment(Qt.AlignCenter)            label.setStyleSheet("border: none; background: transparent;")                        # 智能缩放：不超过屏幕 80%            screen = QDesktopWidget().availableGeometry()            max_w = int(screen.width() * 0.8)            max_h = int(screen.height() * 0.8)                        scaled_pixmap = pixmap.scaled(max_w, max_h, Qt.KeepAspectRatio, Qt.SmoothTransformation)            label.setPixmap(scaled_pixmap)            layout.addWidget(label)                        # 调整窗口大小适应图片（加一点padding）            self.resize(scaled_pixmap.width() + 40, scaled_pixmap.height() + 60)                self._center_on_screen()    def _center_on_screen(self):        screen = QDesktopWidget().screenNumber(QDesktopWidget().cursor().pos())        center = QDesktopWidget().screenGeometry(screen).center()        self.move(center.x() - self.width() // 2, center.y() - self.height() // 2)    def keyPressEvent(self, event):        # 拦截空格键，防止触发其他控件的默认行为，确保只执行关闭        if event.key() == Qt.Key_Space or event.key() == Qt.Key_Escape:            self.close()        else:            super().keyPressEvent(event)class PreviewService:    """    预览服务控制器    负责管理预览窗口的生命周期（打开/关闭）    """    def __init__(self, db_manager, parent_window):        self.db = db_manager        self.parent = parent_window        self.current_dialog = None    def toggle_preview(self, selected_ids):        """        核心逻辑：        1. 如果预览窗口已打开 -> 关闭它        2. 如果预览窗口未打开 -> 获取数据并打开它        """        # --- 状态判断：关闭逻辑 ---        if self.current_dialog and self.current_dialog.isVisible():            self.current_dialog.close()            self.current_dialog = None            return        # --- 状态判断：开启逻辑 ---        if not selected_ids:            return        if len(selected_ids) != 1:            # 如果选中多个，提示只能预览单个            self._show_tooltip('⚠️ 只能预览单个项目')            return        idea_id = list(selected_ids)[0]        self._open_preview(idea_id)    def _open_preview(self, idea_id):        # 获取数据 (包含 blob)        idea = self.db.get_idea(idea_id, include_blob=True)        if not idea:            return        # 解析数据结构 (基于 DatabaseManager 的 schema)        # SELECT * 返回顺序通常是:        # 0:id, 1:title, 2:content, 3:color, 4:pinned, 5:fav,         # 6:created, 7:updated, 8:cat_id, 9:is_deleted, 10:item_type, 11:data_blob, 12:hash                content = idea[2]        # 使用 try-except 或长度检查来防止旧数据库结构导致的索引越界        try:            item_type = idea[10] if len(idea) > 10 else 'text'            data_blob = idea[11] if len(idea) > 11 else None        except IndexError:            item_type = 'text'            data_blob = None        # 确定预览内容        preview_data = None        final_type = 'text'        if item_type == 'image' and data_blob:            final_type = 'image'            preview_data = data_blob        elif content and content.strip():            final_type = 'text'            preview_data = content        else:            self._show_tooltip('⚠️ 内容为空，无法预览')            return        # 创建并显示窗口        self.current_dialog = PreviewDialog(final_type, preview_data, self.parent)                # 关键：当窗口关闭时，清理引用，确保下次 toggle 逻辑正确        self.current_dialog.finished.connect(self._on_dialog_closed)                self.current_dialog.show()    def _on_dialog_closed(self):        self.current_dialog = None    def _show_tooltip(self, msg):        # 调用主窗口的 tooltip 方法（如果存在）        if hasattr(self.parent, '_show_tooltip'):            self.parent._show_tooltip(msg, 1500)