# 快捷笔记 - 应用功能与逻辑文档

本文档旨在详细记录“快捷笔记”桌面应用的全部核心功能、代码逻辑、主要类和方法、参数以及返回值。其目的是为未来的AI或人类开发者提供一份全面的参考，以确保在进行代码修改或功能迭代时，能够充分理解现有实现，避免引入回归性错误或破坏既有功能。

---

## 1. 核心应用逻辑 (`K Main_V3.py`)

该文件是应用的入口点，负责初始化所有核心组件、管理窗口的生命周期，并确保在任何时候只有一个应用实例在运行。

### 1.1. `AppManager` 类

这是应用的核心协调器，负责管理所有窗口和服务的创建与交互。

#### 主要属性:
- `app`: `QApplication` 的实例。
- `db_manager`: `DatabaseManager` 的实例，用于数据库操作。
- `main_window`: `MainWindow` 的实例。**在窗口关闭后会被重置为 `None`**。
- `quick_window`: `QuickWindow` 的实例。**在窗口关闭后会被重置为 `None`**。
- `ball`: `FloatingBall` 的实例。

#### 核心方法:
- **`start()`**:
  - **功能**: 初始化数据库并启动悬浮球。
  - **执行流程**:
    1.  连接数据库 (`DatabaseManager`)。
    2.  创建并显示悬浮球 `FloatingBall`。悬浮球发出的所有请求信号 (如显示窗口、新建笔记、退出应用) 都会被连接到 `AppManager` 中对应的槽函数。
    3.  从设置中加载并恢复悬浮球上次的位置。
- **`show_quick_window()`**:
  - **功能**: **按需创建**并显示快速窗口。
  - **逻辑**:
    - 如果 `self.quick_window` 为 `None` (即窗口从未被打开或已被关闭)，则创建一个新的 `QuickWindow` 实例。
    - 将新窗口的 `destroyed` 信号连接到 `_on_quick_window_destroyed` 槽函数。
    - 显示并激活窗口。
- **`show_main_window()`**:
  - **功能**: **按需创建**并显示主窗口，逻辑同 `show_quick_window`。
- **`_on_quick_window_destroyed()` / `_on_main_window_destroyed()`**:
  - **功能**: (私有槽函数) 当窗口被关闭并销毁时，这两个方法被调用。
  - **逻辑**: 它们的作用是将 `self.quick_window` 或 `self.main_window` 重新设置为 `None`，以便下次可以重新创建。
- **`quit_application()`**:
  - **功能**: 调用 `app.quit()` 来终止并退出整个应用程序。

### 1.2. `main()` 函数

这是应用的启动入口。

#### 功能与执行流程:
1.  **单例应用实现**:
    - 应用启动时，会尝试通过 `QLocalSocket` 连接一个名为 `K_KUAIJIBIJI_SINGLE_INSTANCE_SERVER` 的本地服务。
    - **如果连接成功**: 说明已经有一个实例在运行。新实例会向旧实例发送一个 `EXIT` 消息，强制旧实例退出，然后清理服务，为新实例的启动做准备。
    - **如果连接失败**: 说明没有实例在运行。当前实例会创建一个 `QLocalServer` 并开始监听上述服务名，将自己设为“主实例”。
2.  **应用启动**:
    - 创建 `AppManager` 实例。
    - **`handle_new_connection()` 函数**: 这是为 `QLocalServer` 准备的槽函数。如果另一个新实例尝试启动，它会连接到这个服务。
      - 如果收到的消息是 `SHOW` (这是旧版逻辑，当前逻辑下新实例会发 `EXIT`)，它会调用 `manager.show_quick_window()` 将快速窗口置于前台。
      - 如果收到 `EXIT` 消息，则会调用 `manager.quit_application()` 退出当前实例。
    - 调用 `manager.start()` 来初始化所有组件。
    - 进入 Qt 的主事件循环 `app.exec_()`。

---

## 2. 数据管理核心 (`data/db_manager.py`)

该文件定义了 `DatabaseManager` 类，是与 SQLite 数据库进行所有交互的唯一入口。它封装了所有 SQL 查询，为上层应用提供结构化的数据访问接口。

### 2.1. `DatabaseManager` 类

#### 初始化 (`__init__`)
- **功能**: 连接到名为 `KNote.db` 的 SQLite 数据库。
- **核心设置**:
  - `self.conn.row_factory = sqlite3.Row`: 这是一个非常重要的设置，它使得所有查询返回的结果都是 `sqlite3.Row` 对象。这意味着可以通过**字段名**（如 `result['title']`）和**索引**（如 `result[1]`）两种方式访问数据，极大地增强了代码的可读性和健壮性。
  - `SchemaMigration.apply(self.conn)`: 在连接建立后，立即调用模式迁移模块，确保数据库表结构永远是最新版本。

---

### 2.2. 核心 CRUD (创建、读取、更新、删除) 方法

#### `add_idea(...)`
- **功能**: 向数据库中添加一条新的笔记 (`idea`)。
- **参数**:
  - `title` (str): 笔记标题。
  - `content` (str): 笔记正文。
  - `color` (str): 卡片颜色代码 (如 '#4a90e2')。
  - `tags` (list): 字符串列表，代表笔记的标签。
  - `category_id` (int, optional): 笔记所属的分类ID。
  - `item_type` (str, default='text'): 项目类型 ('text', 'image', 'file')。
  - `data_blob` (bytes, optional): 用于存储图片等二进制数据。
- **返回值**: (int) 新创建笔记的 ID。

#### `update_idea(...)`
- **功能**: 更新一条已存在的笔记。
- **参数**:
  - `iid` (int): 要更新的笔记ID。
  - 其他参数同 `add_idea`。
- **返回值**: 无。

#### `_update_tags(...)`
- **功能**: (私有方法) 更新指定笔记的标签。它会先删除所有旧的标签关联，然后重新绑定新的标签列表。
- **参数**:
  - `iid` (int): 笔记ID。
  - `tags` (list): 新的标签列表。
- **返回值**: 无。

#### `add_clipboard_item(...)`
- **功能**: **专门用于添加剪贴板项目**，并包含**内容去重**的逻辑。
- **参数**:
  - `item_type` (str): 项目类型。
  - `content` (str): 文本内容或文件路径。
  - `data_blob` (bytes, optional): 二进制数据。
  - `category_id` (int, optional): 分类ID。
- **执行流程**:
  1.  根据 `content` 和 `data_blob` 计算出一个 SHA256 哈希值。
  2.  在 `ideas` 表中查询该哈希值是否已存在。
  3.  **如果存在**: 不创建新纪录，只更新该记录的 `updated_at` 时间戳，然后返回其ID。
  4.  **如果不存在**: 创建一条新的笔记记录，并自动为其添加 **"剪贴板"** 标签。
- **返回值**: (int) 笔记的 ID (无论是新建的还是已存在的)。

---

### 2.3. 状态管理方法

这些方法用于修改笔记的元数据或状态。

- **`toggle_field(iid, field)`**:
  - **功能**: 反转一个布尔类型的字段值 (0 -> 1, 1 -> 0)。
  - **应用场景**: 用于“置顶” (`is_pinned`) 和“收藏” (`is_favorite`) 功能。
- **`set_deleted(iid, state)`**:
  - **功能**: 标记或取消标记一条笔记为“已删除”。
  - **核心逻辑**: 当标记为删除 (`state=True`) 时，它同时会更新 `updated_at` 时间戳。这确保了在回收站中，笔记是按照**删除时间**来排序的。
- **`move_category(iid, cat_id)`**:
  - **功能**: 将一条笔记移动到另一个分类下。
- **`delete_permanent(iid)`**:
  - **功能**: **永久删除**一条笔记及其所有关联数据。

---

### 2.4. 查询方法

- **`get_idea(iid, include_blob=False)`**:
  - **功能**: 获取单条笔记的详细信息。
  - **参数**:
    - `iid` (int): 笔记ID。
    - `include_blob` (bool, default=False): 是否在查询结果中包含 `data_blob` 字段。这是一种优化，允许在列表视图等不需要加载大二进制数据的场景下，进行更快的查询。
  - **返回值**: `sqlite3.Row` 对象或 `None`。
- **`get_ideas(search, f_type, f_val)`**:
  - **功能**: **这是应用中最核心和复杂的查询方法**，用于获取笔记列表，支持搜索和多种筛选条件。
  - **参数**:
    - `search` (str): 搜索关键词。会对笔记的 `title`, `content`, 甚至 `tags` 进行模糊匹配 (`LIKE`)。
    - `f_type` (str): 筛选类型。可以是 `'all'`, `'trash'`, `'category'`, `'today'`, `'favorite'` 等。
    - `f_val` (any): 筛选值。例如，当 `f_type` 是 `'category'` 时，`f_val` 就是分类的 ID。
  - **核心逻辑**:
    - 基于 `f_type` 构建不同的 `WHERE` 子句来过滤数据。
    - 如果 `search` 参数不为空，则追加 `LIKE` 条件进行全文搜索。
    - **排序逻辑**:
      - 如果在回收站 (`f_type == 'trash'`)，则按 `updated_at` (即删除时间) 降序排列。
      - 在其他所有视图中，都按 `is_pinned` (置顶) 优先，然后再按 `updated_at` 降序排列。
  - **返回值**: 一个包含多个 `sqlite3.Row` 对象的列表。
- **`get_tags(iid)`**:
  - **功能**: 获取指定笔记的所有标签。
  - **返回值**: (list) 字符串列表。
- **`get_categories()`**:
  - **功能**: 获取所有分类。
  - **返回值**: 包含分类信息的 `sqlite3.Row` 对象列表。
- **`get_partitions_tree()`**:
  - **功能**: 查询所有分类并将其在内存中构建成一个**层级树结构**。
  - **返回值**: 一个包含顶层 `Partition` 对象的列表，每个 `Partition` 对象可能包含 `children` 列表。
- **`get_counts()` / `get_partition_item_counts()`**:
  - **功能**: 执行一系列 `COUNT(*)` 查询，为UI（主要是侧边栏）提供各种分类下的笔记数量统计。

---

### 2.5. 分类管理方法

- **`add_category(name, parent_id=None)`**: 添加新分类。
- **`rename_category(cat_id, new_name)`**: 重命名分类。
- **`delete_category(cid)`**: 删除分类。
- **`save_category_order(update_list)`**:
  - **功能**: 批量更新分类的顺序 (`sort_order`) 和父子关系 (`parent_id`)。
  - **应用场景**: 用于支持侧边栏中分类的拖拽排序功能。

---

## 3. 主窗口 (`ui/main_window.py`)

`MainWindow` 是应用的核心用户界面，提供全面的笔记管理功能。它是一个无边框的自定义窗口，并实现了自己的拖动和调整大小逻辑。

### 3.1. 初始化 (`__init__`)
- **功能**: 初始化主窗口的所有组件、服务和状态。
- **核心操作**:
  - 创建 `DatabaseManager` 实例用于数据访问。
  - 创建 `PreviewService` 实例，用于实现空格键预览功能。
  - 初始化状态变量，如 `self.curr_filter` (当前筛选器)、`self.selected_ids` (当前选中的卡片ID集合)。
  - 设置窗口为无边框 (`Qt.FramelessWindowHint`) 和透明背景 (`Qt.WA_TranslucentBackground`)。
    - **`setAttribute(Qt.WA_DeleteOnClose)`**: 设置此属性，确保窗口关闭时被彻底销毁。
  - 调用 `_setup_ui()` 构建界面，然后调用 `_load_data()` 加载初始数据。

---

### 3.2. UI 构建 (`_setup_ui` 及相关方法)

- **`_setup_ui()`**:
  - **功能**: 组装整个主窗口的UI布局。
  - **核心组件**:
    - **`_create_titlebar()`**: 创建顶部的自定义标题栏，包含标题、搜索框和窗口控制按钮（最小化、最大化、关闭）。
    - **`_create_middle_panel()`**: 创建中部的主要内容区域，包含操作按钮栏 (`pin`, `fav`, `edit` 等) 和一个用于显示笔记卡片的 `QScrollArea`。
    - **`_create_tag_panel()`**: 创建右侧的标签面板，显示所有标签及其计数。
    - **`Sidebar`**: 创建左侧的侧边栏，用于分类和筛选。
  - **布局**: 使用 `QSplitter` 将侧边栏、中间内容面板和标签面板分隔开，允许用户自由调整它们的宽度。
  - **快捷键**: 在这里定义了大量的全局快捷键，如 `Ctrl+N` (新建)、`Ctrl+W` (关闭)、`Delete` (删除) 等。

- **自定义窗口逻辑**:
  - `mousePressEvent`, `mouseMoveEvent`, `mouseReleaseEvent` 被重写，以实现无边框窗口的拖动（当鼠标在标题栏区域按下时）和八个方向的缩放（当鼠标在窗口边缘时）。

---

### 3.3. 数据加载与刷新

- **`_load_data()`**:
  - **功能**: **这是刷新主列表视图的核心方法**。
  - **执行流程**:
    1.  清空当前 `list_layout` 中的所有旧卡片。
    2.  调用 `self.db.get_ideas()` 方法，传入当前的搜索词 (`self.search.text()`) 和筛选条件 (`self.curr_filter`) 来获取数据。
    3.  如果设置了标签筛选 (`self.current_tag_filter`)，则在内存中对结果进行二次过滤。
    4.  遍历查询到的数据列表，为每一条数据创建一个 `IdeaCard` 实例。
    5.  **信号连接**:
        - `selection_requested`: 连接到 `_handle_selection_request`，处理单击和Ctrl+单击选中。
        - `deletion_requested`: 连接到 `_handle_card_deletion`，处理拖拽删除。
        - `double_clicked`: 连接到 `_extract_single`，处理双击复制内容。
    6.  将所有新建的卡片添加到 `list_layout` 中。
    7.  在布局末尾添加一个**弹簧 (`addStretch`)**，以防止出现多余的滚动空白。
    8.  调用 `_update_ui_state()` 更新顶部操作按钮的可用状态。
    9.  通过 `QTimer.singleShot` 延迟调用 `_check_scroll_position`，以更新“我也是有底线的”标签的状态。
- **`_refresh_all()`**:
  - **功能**: 一个便捷的“完全刷新”方法。
  - **执行流程**: 依次调用 `_load_data()` (刷新列表)、`self.sidebar.refresh()` (刷新侧边栏计数)、`_update_ui_state()` (刷新按钮) 和 `_refresh_tag_panel()` (刷新标签列表)。

---

### 3.4. 核心交互处理

- **`_handle_selection_request(iid, is_ctrl_pressed)`**:
  - **功能**: 处理卡片的点击选择事件。
  - **逻辑**:
    - 如果 `Ctrl` 键**没有**被按下：清空 `selected_ids` 集合，然后只将当前点击的卡片ID加入。
    - 如果 `Ctrl` 键被按下：如果卡片已在 `selected_ids` 中，则移除；否则，加入。
  - **最后**: 调用 `_update_all_card_selections()` 来更新所有卡片的视觉样式，并调用 `_update_ui_state()`。

- **`_update_ui_state()`**:
  - **功能**: 根据当前选中的卡片数量 (`len(self.selected_ids)`) 来更新顶部操作按钮（编辑、删除、置顶等）的**可见性**和**可用性**。
  - **逻辑**:
    - “编辑”按钮仅在 `len == 1` 时可用。
    - “删除”、“置顶”、“收藏”等按钮在 `len >= 1` 时可用。
    - 在回收站视图中，按钮会切换为“恢复”和“永久删除”。

- **`_handle_card_deletion(idea_id)`**:
  - **功能**: 处理拖拽删除信号。
  - **逻辑**: 调用 `self.db.set_deleted(idea_id, True)` 将笔记移入回收站，然后调用 `_refresh_all()` 刷新整个界面。

- **`_set_filter(f_type, val)`**:
  - **功能**: 接收来自 `Sidebar` 的信号，设置新的筛选条件并重新加载数据。
  - **参数**:
    - `f_type` (str): 筛选类型 (如 'category', 'trash')。
    - `val` (any): 筛选值 (如分类ID)。

- **`_extract_single(idea_id)`**:
  - **功能**: 提取单条笔记的正文内容到系统剪贴板。

- **按钮操作 (`_do_del`, `_do_pin`, `_do_fav`, `_do_edit` 等)**:
  - **功能**: 这些方法对应顶部操作栏的各个按钮。
  - **逻辑**: 它们会遍历 `self.selected_ids` 集合中的所有ID，并调用 `DatabaseManager` 中相应的方法来执行批量操作 (如批量删除、批量置顶)。

---

## 4. 快速窗口 (`ui/quick_window.py`)

`QuickWindow` 是一个轻量级的桌面小部件，其主要定位是**剪贴板历史管理器**。它的核心功能是快速访问、搜索剪贴板历史，并能将选中的历史记录“粘贴”回上一个活动的应用窗口。

### 4.1. 初始化 (`__init__`)
- **功能**: 初始化快速窗口的UI、服务和状态。
- **核心操作**:
  - `self.settings = QSettings("MyTools", "RapidNotes")`: 创建 `QSettings` 实例，用于**持久化存储**窗口的状态（如位置、大小）。
  - `self.cm = ClipboardManager(self.db)`: 创建剪贴板管理器实例。
  - `self.clipboard.dataChanged.connect(self.on_clipboard_changed)`: **连接系统剪贴板内容变化的信号**，这是实现自动捕获的核心。
  - 调用 `_init_ui()` 构建界面，并通过 `_restore_window_state()` 恢复上次关闭时的窗口位置和大小。
  - `self.monitor_timer`: 在 Windows 平台上，启动一个定时器，周期性调用 `_monitor_foreground_window` 来追踪当前哪个窗口是活动窗口。

### 4.2. 核心功能与逻辑

#### 剪贴板自动捕获
- **`on_clipboard_changed()`**:
  - **功能**: 当系统剪贴板内容发生变化时，此槽函数被触发。
  - **逻辑**: 它会获取剪贴板的 `mimeData`，并调用 `self.cm.process_clipboard()` 来处理新内容。
- **`_on_data_captured(idea_id)`**:
  - **功能**: 当 `ClipboardManager` 成功捕获并保存一条新数据后，会发出信号触发此方法。
  - **逻辑**:
    1.  调用 `_update_list()` 刷新列表，将新捕获的内容显示在最上方。
    2.  弹出一个 `TagSuggestionDialog`，让用户可以快速为新条目添加标签。

#### 列表展示与筛选
- **`_update_list()`**:
  - **功能**: 刷新剪贴板历史列表。
  - **逻辑**:
    1.  从搜索框 (`self.search_box`) 和侧边栏 (`self.partition_tree`) 获取当前的搜索词和筛选条件。
    2.  调用 `self.db.get_ideas()` 查询数据库。
    3.  清空 `QListWidget`，并为每一条返回的数据创建一个 `QListWidgetItem`。
    4.  `_get_content_display()`: 这是一个辅助方法，根据项目类型（文本、图片、文件）来生成在列表中显示的摘要文本。
- **`_update_partition_tree()`**:
  - **功能**: 刷新右侧的分类（分区）树，并更新每个分类下的项目计数。

#### “Ditto-style” 粘贴功能
这是 `QuickWindow` 最具特色的功能，它模拟了著名剪贴板工具 Ditto 的粘贴行为。
- **`_on_item_activated(item)`**:
  - **功能**: 当用户在列表中双击或按回车激活一个条目时触发。
  - **执行流程**:
    1.  从 `QListWidgetItem` 中获取其关联的笔记数据。
    2.  **内容准备**: 根据 `item_type`，将数据转换成合适的剪贴板格式。
        - **图片**: 从 `data_blob` 中加载图片数据，并将其放入系统剪贴板。
        - **文件**: 将文件路径字符串转换为 `QUrl` 列表，并放入剪贴板。
        - **文本**: 直接将文本内容放入剪贴板。
    3.  调用 `self._paste_ditto_style()` 执行粘贴。
- **`_paste_ditto_style()`**:
  - **功能**: (仅限 Windows) 模拟用户操作，将剪贴板内容粘贴到之前的活动窗口。
  - **依赖**: 此功能严重依赖 `_monitor_foreground_window` 方法预先捕获到的窗口句柄 (`self.last_active_hwnd`, `self.last_focus_hwnd`)。
  - **执行流程**:
    1.  使用 Win32 API (`SetForegroundWindow`) 强制将之前记录的活动窗口带到前台。
    2.  如果可能，使用 `SetFocus` 将焦点设置到该窗口中之前有焦点的控件上。
    3.  使用 `keybd_event` API **模拟一次 `Ctrl+V` 按键**。

### 4.3. 窗口管理与状态持久化
- **`_restore_window_state()`**:
  - **功能**: 在窗口启动时，从 `QSettings` 中读取并恢复上次的几何位置 (`geometry`)、分割条状态 (`splitter_state`) 和侧边栏可见性 (`partition_panel_hidden`)。
- **`closeEvent(event)`**:
  - **功能**: 重写窗口的关闭事件以保存状态。
  - **逻辑**:
    1.  将当前窗口的位置、大小等状态保存到 `QSettings` 中。
    2.  调用 `super().closeEvent(event)` 来执行默认的关闭行为，由于在 `__init__` 中设置了 `Qt.WA_DeleteOnClose` 属性，窗口将被**彻底销毁**。

---

## 5. 关键 UI 组件与服务

### 5.1. 笔记卡片 (`ui/cards.py`)

`IdeaCard` 是主窗口中用于展示单条笔记信息的核心UI组件。

#### 主要功能与逻辑:
- **数据展示**:
  - 在 `_init_ui` 方法中，根据从数据库查询到的 `data` (一个 `sqlite3.Row` 对象) 来构建卡片界面，包括标题、内容预览、置顶/收藏图标、时间戳和标签。
- **样式更新**:
  - `update_selection(selected)`: 根据卡片是否被选中，动态地改变其边框样式，以提供清晰的视觉反馈。
- **用户交互**:
  - **单击**: `mouseReleaseEvent` 会检测是否为一次简单的单击操作。如果是，则发射 `selection_requested(id, is_ctrl_pressed)` 信号，通知主窗口处理选中逻辑。
  - **双击**: `mouseDoubleClickEvent` 会发射 `double_clicked(id)` 信号，通知主窗口执行提取内容到剪贴板的操作。
  - **拖拽删除**:
    - `mousePressEvent`: 记录拖拽的起始位置。
    - `mouseMoveEvent`: 实时计算向右拖拽的距离，并通过 `self.move()` 移动卡片。同时调用 `_update_drag_style()`，根据拖拽距离将卡片背景从原始颜色平滑地插值过渡到红色，提供强烈的视觉反馈。
    - `mouseReleaseEvent`: 判断最终的拖拽距离。
      - **如果 > 100 像素**: 发射 `deletion_requested(id)` 信号，请求主窗口删除此卡片。
      - **如果 < 100 像素**: 播放一个 `QPropertyAnimation` 动画，将卡片平滑地弹回其原始位置。
  - **右键菜单**: 卡片的 `customContextMenuRequested` 信号被连接到主窗口的 `_show_card_menu` 方法，用于显示上下文菜单。

---

### 5.2. 侧边栏 (`ui/sidebar.py`)

`Sidebar` 是主窗口左侧的导航面板，负责提供数据筛选功能，并允许用户管理分类。

#### 主要功能与逻辑:
- **UI 构建**:
  - 使用 `QTreeWidget` 来展示一个层级化的树状列表。
  - 列表分为两个顶层部分：“系统” (包含“全部数据”、“今日数据”、“回收站”等静态项) 和“我的分区” (用户自定义的分类)。
- **数据刷新**:
  - `refresh()`: 这是侧边栏的核心方法，用于重新加载所有数据并更新UI。
  - **执行流程**:
    1.  调用 `self.db.get_counts()` 获取各类别的笔记数量统计。
    2.  更新“系统”项的文本，附加上最新的数量 (如 “全部数据 (159)”)。
    3.  调用 `self.db.get_partitions_tree()` 获取用户分类的树状结构。
    4.  递归地将用户分类添加到 `QTreeWidget` 中。
- **用户交互**:
---

### 3.5. 窗口关闭行为

- **`closeEvent(event)`**:
  - **功能**: 重写窗口的关闭事件。
  - **逻辑**: 调用 `super().closeEvent(event)` 来执行默认的关闭行为。由于在 `__init__` 中设置了 `Qt.WA_DeleteOnClose` 属性，窗口将被**彻底销毁**。
  - **点击项目**: 当用户点击树中的任何一项时，`currentItemChanged` 信号会触发 `_on_filter_changed` 方法。
  - **`_on_filter_changed`**: 该方法会解析被点击项的数据，并**发射 `filter_changed(filter_type, filter_value)` 信号**。主窗口 `MainWindow` 会监听此信号，并根据收到的筛选条件刷新笔记列表。
  - **右键菜单**:
    - 提供了“新建分类”、“重命名”、“删除”等操作。
    - 这些操作**只对“我的分区”下的项目有效**，“系统”项的右键菜单被禁用。
    - 当用户执行了会改变数据结构的操作时 (如新建、删除分类)，会**发射 `data_changed` 信号**，通知主窗口需要进行一次全面的数据刷新。
  - **拖拽排序**:
    - 侧边栏启用了 `QTreeWidget` 的拖放功能 (`InternalMove`)。
    - 用户可以在“我的分区”内或之间拖动分类，以改变它们的顺序和层级关系。
    - 拖拽操作结束后，`dropEvent` 会被触发，在其中调用 `self.db.save_category_order()` 将新的树结构持久化到数据库。

---

### 5.3. 剪贴板服务 (`services/clipboard.py`)

`ClipboardManager` (在 `clipboard.py` 中定义) 是一个更高层次的封装，它直接与 `QApplication.clipboard()` 交互，并协调数据库操作。

#### 主要功能与逻辑:
- **`process_clipboard(mime_data, cat_id=None)`**:
  - **功能**: 这是处理剪贴板内容的核心入口。
  - **参数**:
    - `mime_data` (`QMimeData`): 从系统剪贴板获取的原始数据。
    - `cat_id` (int, optional): (此参数在快速窗口中未使用) 指定要将捕获内容存入的分类ID。
  - **执行流程**:
    1.  **优先级判断**: 按照 `文件 -> 图片 -> 文本` 的顺序检查 `mime_data` 中包含的数据类型。
    2.  **文件处理**: 如果 `mime_data.hasUrls()` 为真，提取所有本地文件路径，用分号 `;` 连接成一个字符串，然后调用 `self.db.add_clipboard_item()` 并将 `item_type` 设为 `'file'`。
    3.  **图片处理**: 如果 `mime_data.hasImage()` 为真，将图片数据编码为 PNG 格式的字节流，然后调用 `add_clipboard_item()`，将 `item_type` 设为 `'image'`，并将字节流作为 `data_blob` 传入。
    4.  **文本处理**: 如果 `mime_data.hasText()` 为真，直接将文本内容传入 `add_clipboard_item()`，`item_type` 为 `'text'`。
    5.  **数据捕获信号**: 在 `add_clipboard_item` 成功返回一个 `idea_id` (无论是新建还是更新) 后，会**发射 `data_captured(idea_id)` 信号**。快速窗口 `QuickWindow` 会监听此信号来触发UI刷新和标签建议。

---
