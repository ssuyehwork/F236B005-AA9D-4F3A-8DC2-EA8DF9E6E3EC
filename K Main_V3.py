# main.pyimport sysimport timefrom PyQt5.QtWidgets import QApplicationfrom PyQt5.QtNetwork import QLocalServer, QLocalSocketfrom ui.main_window import MainWindowSERVER_NAME = "rapidnotes_pro_server"def main():    app = QApplication(sys.argv)    app.setStyle('Fusion')        print("[DEBUG] 正在检查是否有旧实例运行...")        # 尝试连接已有实例    socket = QLocalSocket()    socket.connectToServer(SERVER_NAME)        if socket.waitForConnected(500):        print("[DEBUG] 检测到旧实例，发送退出指令...")        # 发送退出指令给旧实例        socket.write(b"EXIT")        socket.flush()        socket.waitForBytesWritten(1000)        socket.disconnectFromServer()                # 等待旧实例完全退出        print("[DEBUG] 等待旧实例退出...")        time.sleep(0.5)                # 清理可能残留的服务器        QLocalServer.removeServer(SERVER_NAME)        print("[DEBUG] 旧实例已清理")    else:        print("[DEBUG] 没有检测到旧实例")        # 清理可能的僵尸服务器        QLocalServer.removeServer(SERVER_NAME)        # 创建新的服务器（当前实例）    print("[DEBUG] 创建新实例服务器...")    server = QLocalServer()        if not server.listen(SERVER_NAME):        print(f"[ERROR] 无法创建服务器: {server.errorString()}")        # 强制删除并重试        QLocalServer.removeServer(SERVER_NAME)        if not server.listen(SERVER_NAME):            print("[ERROR] 重试失败，继续运行但不支持单实例检测")    else:        print("[DEBUG] 服务器创建成功")        def handle_new_connection():        """处理新实例的连接请求"""        conn = server.nextPendingConnection()        if conn and conn.waitForReadyRead(500):            msg = conn.readAll().data().decode()            print(f"[DEBUG] 收到新实例消息: {msg}")            if msg == "EXIT":                print("[DEBUG] 收到退出指令，准备退出...")                # 当前实例收到退出指令 → 立即退出                app.quit()        server.newConnection.connect(handle_new_connection)        # 创建并显示主窗口    print("[DEBUG] 创建主窗口...")    window = MainWindow()    window.show()        print("[DEBUG] 应用程序启动完成")    sys.exit(app.exec_())if __name__ == '__main__':    main()